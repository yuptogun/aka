# 자습 일지: 12일차 2024-05-06

## 클라이언트 먼저 하고 그 위에 인증을 붙이자

철저히 백엔드 개발이라는 관점만 관철하자면, 이런 순서로 진행해도 됐을 것이다.

1. 클라이언트 관점은 무시하고 `Authorization: Bearer`에 JWT를 요구하는 방식으로 인증 구현한다.
2. 그걸 할 수 있는 클라이언트를 구현한다.

근데 왠지 직감상 2번에서 엄청 죽을 쑬 것 같은 기분이 들었다.  
사실 실무에서 사용자 인증이라는 건, 토큰 까서 읽고 쓰고 하는 건 재미있는 부분이고, 재미없는 부분들은 거의 대부분이 클라이언트 영역이다.

* 입력 validation
* 신원확인 - email verification 등
* 사용자 상태 관리 - suspended, 권한 등

그리고... 내 나이 서른여섯... Java도 아니고 내내 PHP 웹개발만 고집(???)해 온 입장이 되고 보면...  
이젠 한쪽 스택만 계속하겠다고 투정 부려선 안되는 것이다...  
우라질 놈의 풀 스택 이라는 걸 해야... 내 연차에 맞는 밥벌이가 될 것이다...
흐규 흐규......

고민을 조금 한 뒤 눈물을 머금고 다음 순서로 진행하기로 했다.

1. 클라이언트를 구현한다.
2. 1에 지금까지 만든 서버를 붙인다. 이 과정에서 인증 구현한다.

사실 이렇게 순서 바꾸게 된 이유가 하나 더 있는데, Node 기반 개발에서 서버-클라이언트 연동이란 항상 어딘가 이상하게 골치가 아픈 영역인 것 같아서다.

## Nuxt 선택

### 원래는 모노리스를 만들고 싶었으나

PHP(특히 라라벨)나 Java는 서버측이 클라이언트측을 겸임하겠다는 주의다.  
대부분의 예제가 "클라이언트 빌드를 만든 다음 그걸 서버가 정적 서빙하게 하세요!"로 되어 있다.  
모노리스라고 불러도 좋겠지.

파이썬, Node.js 계열은 서버도 클라이언트도 서로를 겸임하지 않는 편이다.  
대부분의 예제가 서로 다른 두 포트에서 서로 다른 앱을 서빙하고, 서버측이 CORS를 허용한다.  
물론 일부 극소수의 경우 한 node 앱이 다른 node 앱의 빌드를 가져다 써서 최종 빌드를 꾸리는 방향도 없지는 않다.  
하지만 그 사례들은 대부분 프로덕션/헬로월드 차원만 생각하고 있고, 개발 환경은 세팅하기가 까다로워서 인기가 없는 모양이더군.

PHP측 개념을 포기하기가 너무 어려웠다.  
아니 왜 모노리스가 안 돼. 앱이 하나면 포트도 하나여야 하는 거 아닌가? 왜 이 둘을 따로 띄워야 하는 거야?? `npm run dev` 두개 돌리는 게 이게 맞아???  
일단은 더 싸우기 싫어서, 그리고 하고 싶은 게 있어서 Nuxt 선택했고 둘을 분리했다.  
조만간 내부 프록싱을 돌리든지 해야지 안되겠다 싶다.

### Nuxt는 웹프레임워크라기보다는 사이트 제작 도구

이런저런 옵션들을 둘러보다가 [Nuxt](https://nuxt.com/)를 선택했다.  
React는 언감생심이고, Vue 기반 프레임워크 괜찮은 게 뭐 있나 보니 달리 더 없어 보여서.  
그나마도 처음 Nuxt 설치할 때는 다음과 같은 꿈에 부풀어 있었다.

> Nuxt가 nitro라는 "서버"를 내장하고 있다는 모양인데...  
> 그러면 거기에 지금까지 짠 비즈니스 로직을 다 옮기면 API 통폐합이 되겠지?

근데 기존 비즈니스 로직은 내 DB에 내 TypeORM repo로 쿼리를 치는 로직이란 말이지.  
그러면 [Nuxt에서 PostgreSQL을 어케 쓸 수 있나...?](https://nuxt.com/modules?q=&category=Database)  
하고 보니 [Supabase](https://supabase.nuxtjs.org/)인지 뭔지 하는 게 튀어나오고 막상 평범한 PostgreSQL 모듈 같은 건 없다.  
그나마도 이 서비스... SaaS인데다가 [Pricing](https://supabase.com/pricing)까지 붙어 있어...  
천천히 뒷걸음질쳐서 나왔고 꿈은 깨졌다.

그제야 다시 보이기 시작한 Modules 목록...  
여기서 이해한 것은, Nuxt는 클라이언트에 특화된 웹프레임워크라기보다는, 웹사이트를 제작하는 도구에 가깝다는 것이다.

* [그럴듯한 때깔의 템플릿들을 자랑하는 메뉴](https://nuxt.com/templates)가 따로 있는 것은 그 때문이다.
* 기본 골조는 갖추어져 있다. 예약된 폴더 이름들이 꽤 있다.
* 모든 기능/모듈은 본질적으로 '플러그인'이다.
* (그닥 안 맞는 비유이긴 하지만) 마치 OctoberCMS가 라라벨로 만들었지만 100% 자유로운 라라벨 앱은 아니듯이, Nuxt도 Vue로 만들었지만 100% 자유로운 Vue 앱은 아닌 것이다.
* DB, '백엔드 서버' 등이 묘하게 빈약한 것은 그 때문이다. 그게 관심사가 아니기 때문이다.

다시 Modules를 쭉 둘러보고, 필요한 것만 주워다 쓰기로 결심한다.

```shell
npx nuxi init -t ui client
cd client/
npx nuxi@latest module add content
```

## Nuxt 특이사항

### import는 자동으로 된다

기본 만들어져 있는 `app.vue`에는 `import`가 없었다.

```html
<template>
  <UContainer>
    ...
  </UContainer>
</template>
```

아하 `UContainer` 컴포넌트는 UI 모듈 로딩할 때 알아서 import를 한 모양이구나~  
그럼 내가 만든 컴포넌트는 import를 해야겠지?  
그것도 필요가 없었다.

```html
<div class="...">
  <div class="...">
    <Header></Header>
  </div>
  <Journal></Journal>
</div>
```

왜 이게 작동해??? 싶은데, 아마 바로 이걸 해 주는 게 Nuxt의 좋은 점일 거라고 대강 짐작하고 지나간다.  
주어지는 혜택에는 의문을 품지 말자!!!

### `pages/`, `layouts/` 폴더는 안 만들어도 된다

앱 레이아웃을 만들어야 할 텐데... 하고 이리저리 찾아보며 헤매다가 확인한 내용.

`app.vue` 파일은, [라우팅이 필요없는 진짜 1페이지짜리 앱을 만들 때 유용하다.](https://nuxt.com/docs/guide/directory-structure/app#minimal-usage) (지금처럼.)  
아니라면, [그때에야 비로소 `pages/`라는 폴더를 만들고](https://nuxt.com/docs/getting-started/views#pages) `app.vue`를 대체하는 것이 좋다.  
요컨대, `app.vue`를 쓰든지, `pages/**.vue`를 쓰든지 둘 중 하나인 것.  
지금 당장은 로그인/가입 등의 페이지가 없으니 `app.vue` 하나로 버티기로 한다.

지금 다시 살펴보니 [레이아웃 구현 방법](https://nuxt.com/docs/getting-started/views#layouts)도 이미 준비가 돼 있었다.  
`layouts/`라는 폴더를 만들어서 `default.vue` 파일 만들면 된다고 한다.  
여기서도 `app.vue`는 꾸준히 강조된다.

> 애플리케이션이 사용할 레이아웃이 하나뿐이라면, 그냥 `app.vue`에서 `<NuxtPage />`를 사용하는 방향을 추천합니다.

아무래도 `app.vue`는 계속 쓰이겠군...

## 13일차 예고

주로 클라이언트 refinement 내용을 다룰 예정.

- Nuxt + NestJS 연동 (일단) 완료하기까지
- nuxt-ui, nuxt-content 모듈 특이사항 약간
- TailwindCSS 특이사항 약간